diff --git a/hphp/hack/src/deps/rust/file_info/Cargo.toml b/hphp/hack/src/deps/rust/file_info/Cargo.toml
index e18d598acef..f6bcfff8735 100644
--- a/hphp/hack/src/deps/rust/file_info/Cargo.toml
+++ b/hphp/hack/src/deps/rust/file_info/Cargo.toml
@@ -18,7 +18,9 @@ ocamlrep = { version = "0.1.0", git = "https://github.com/facebook/ocamlrep/", b
 parser_core_types = { version = "0.0.0", path = "../../../parser/cargo/core_types" }
 rc_pos = { version = "0.0.0", path = "../../../utils/rust/pos" }
 relative_path = { version = "0.0.0", path = "../../../utils/rust/relative_path" }
-rusqlite = { version = "0.28.0", features = ["backup", "blob", "column_decltype"] }
 serde = { version = "1.0.136", features = ["derive", "rc"] }
 thiserror = "1.0.36"
 typing_deps_hash = { version = "0.0.0", path = "../../cargo/typing_deps_hash" }
+
+[target.'cfg(not(target_arch = "wasm32"))'.dependencies]
+rusqlite = { version = "0.28.0", features = ["backup", "blob", "column_decltype"] }
\ No newline at end of file
diff --git a/hphp/hack/src/deps/rust/file_info_lib.rs b/hphp/hack/src/deps/rust/file_info_lib.rs
index 6092c509de9..6c9bc532695 100644
--- a/hphp/hack/src/deps/rust/file_info_lib.rs
+++ b/hphp/hack/src/deps/rust/file_info_lib.rs
@@ -16,10 +16,13 @@ mod s_set {
 }
 
 use naming_types::KindOfType;
-use relative_path::RelativePath;
+#[cfg(unix)]
 use rusqlite::types::FromSql;
+#[cfg(unix)]
 use rusqlite::types::FromSqlError;
+#[cfg(unix)]
 use rusqlite::types::FromSqlResult;
+#[cfg(unix)]
 use rusqlite::types::ValueRef;
 
 impl From<Mode> for parser_core_types::FileMode {
@@ -49,15 +52,6 @@ impl std::cmp::PartialEq<Mode> for parser_core_types::FileMode {
     }
 }
 
-impl Pos {
-    pub fn path(&self) -> &RelativePath {
-        match self {
-            Pos::Full(pos) => pos.filename(),
-            Pos::File(_, path) => path,
-        }
-    }
-}
-
 impl From<KindOfType> for NameType {
     fn from(kind: KindOfType) -> Self {
         match kind {
@@ -94,6 +88,7 @@ impl From<NameType> for typing_deps_hash::DepType {
     }
 }
 
+#[cfg(unix)]
 impl FromSql for NameType {
     fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
         match value {
@@ -117,6 +112,7 @@ impl FromSql for NameType {
     }
 }
 
+#[cfg(unix)]
 impl rusqlite::ToSql for NameType {
     fn to_sql(&self) -> rusqlite::Result<rusqlite::types::ToSqlOutput<'_>> {
         Ok(rusqlite::types::ToSqlOutput::from(*self as i64))
diff --git a/hphp/hack/src/naming/names_rust/Cargo.toml b/hphp/hack/src/naming/names_rust/Cargo.toml
index 5a208a46ea0..928361a5bf8 100644
--- a/hphp/hack/src/naming/names_rust/Cargo.toml
+++ b/hphp/hack/src/naming/names_rust/Cargo.toml
@@ -16,6 +16,8 @@ oxidized = { version = "0.0.0", path = "../../oxidized" }
 oxidized_by_ref = { version = "0.0.0", path = "../../oxidized_by_ref" }
 rand = { version = "0.8", features = ["small_rng"] }
 relative_path = { version = "0.0.0", path = "../../utils/rust/relative_path" }
-rusqlite = { version = "0.28.0", features = ["backup", "blob", "column_decltype"] }
 serde = { version = "1.0.136", features = ["derive", "rc"] }
 typing_deps_hash = { version = "0.0.0", path = "../../deps/cargo/typing_deps_hash" }
+
+[target.'cfg(not(target_arch = "wasm32"))'.dependencies]
+rusqlite = { version = "0.28.0", features = ["backup", "blob", "column_decltype"] }
\ No newline at end of file
diff --git a/hphp/hack/src/naming/names_rust/datatypes.rs b/hphp/hack/src/naming/names_rust/datatypes.rs
index 91106097aa3..930dfa897c5 100644
--- a/hphp/hack/src/naming/names_rust/datatypes.rs
+++ b/hphp/hack/src/naming/names_rust/datatypes.rs
@@ -11,9 +11,13 @@ use oxidized::file_info::Mode;
 use oxidized::file_info::NameType;
 use relative_path::Prefix;
 use relative_path::RelativePath;
+#[cfg(unix)]
 use rusqlite::types::FromSql;
+#[cfg(unix)]
 use rusqlite::types::FromSqlError;
+#[cfg(unix)]
 use rusqlite::types::FromSqlResult;
+#[cfg(unix)]
 use rusqlite::types::ValueRef;
 
 #[derive(Debug, Default)]
@@ -83,6 +87,7 @@ impl FileInfoId {
     }
 }
 
+#[cfg(unix)]
 impl rusqlite::ToSql for FileInfoId {
     fn to_sql(&self) -> rusqlite::Result<rusqlite::types::ToSqlOutput<'_>> {
         Ok(rusqlite::types::ToSqlOutput::from(self.0.get() as i64))
diff --git a/hphp/hack/src/naming/names_rust/naming_sqlite.rs b/hphp/hack/src/naming/names_rust/naming_sqlite.rs
index 6972660fea5..574f249d9bb 100644
--- a/hphp/hack/src/naming/names_rust/naming_sqlite.rs
+++ b/hphp/hack/src/naming/names_rust/naming_sqlite.rs
@@ -12,8 +12,11 @@ use hh24_types::ToplevelCanonSymbolHash;
 use hh24_types::ToplevelSymbolHash;
 use oxidized::file_info::NameType;
 use relative_path::RelativePath;
+#[cfg(unix)]
 use rusqlite::params;
+#[cfg(unix)]
 use rusqlite::Connection;
+#[cfg(unix)]
 use rusqlite::OptionalExtension;
 
 pub struct Names {
diff --git a/hphp/hack/src/oxidized/aast_visitor/node_impl_gen.rs b/hphp/hack/src/oxidized/aast_visitor/node_impl_gen.rs
index 33a47588685..5b9dc61eaf1 100644
--- a/hphp/hack/src/oxidized/aast_visitor/node_impl_gen.rs
+++ b/hphp/hack/src/oxidized/aast_visitor/node_impl_gen.rs
@@ -2133,7 +2133,6 @@ impl<P: Params> Node<P> for Typedef<P::Ex, P::En> {
         self.file_attributes.accept(c, v)?;
         self.mode.accept(c, v)?;
         self.vis.accept(c, v)?;
-        self.namespace.accept(c, v)?;
         self.span.accept(c, v)?;
         self.emit_id.accept(c, v)?;
         self.is_ctx.accept(c, v)?;
diff --git a/hphp/hack/src/oxidized/aast_visitor/node_mut_impl_gen.rs b/hphp/hack/src/oxidized/aast_visitor/node_mut_impl_gen.rs
index e4430459744..06ea21523e1 100644
--- a/hphp/hack/src/oxidized/aast_visitor/node_mut_impl_gen.rs
+++ b/hphp/hack/src/oxidized/aast_visitor/node_mut_impl_gen.rs
@@ -2133,7 +2133,6 @@ impl<P: Params> NodeMut<P> for Typedef<P::Ex, P::En> {
         self.file_attributes.accept(c, v)?;
         self.mode.accept(c, v)?;
         self.vis.accept(c, v)?;
-        self.namespace.accept(c, v)?;
         self.span.accept(c, v)?;
         self.emit_id.accept(c, v)?;
         self.is_ctx.accept(c, v)?;
diff --git a/hphp/hack/src/oxidized/manual/errors_impl.rs b/hphp/hack/src/oxidized/manual/errors_impl.rs
index 1c6b99eac19..805260e81f4 100644
--- a/hphp/hack/src/oxidized/manual/errors_impl.rs
+++ b/hphp/hack/src/oxidized/manual/errors_impl.rs
@@ -68,11 +68,7 @@ impl<PP: Ord + FileOrd, P: Ord + FileOrd> UserError<PP, P> {
                 self_code.cmp(&other_code)
             }
         };
-        // The primary sort order is by file of the claim (main message).
-        self_pos
-            .cmp_file(other_pos)
-            // If the files are the same, sort by error code or phase, depending on parameter.
-            .then(compare_code(*self_code, *other_code))
+        compare_code(*self_code, *other_code)
             // If the phases are the same, sort by position.
             .then(self_pos.cmp(other_pos))
             // If the positions are the same, sort by claim message text.
@@ -85,13 +81,9 @@ impl<PP: Ord + FileOrd, P: Ord + FileOrd> UserError<PP, P> {
 }
 
 pub trait FileOrd {
-    fn cmp_file(&self, other: &Self) -> Ordering;
 }
 
 impl FileOrd for Pos {
-    fn cmp_file(&self, other: &Self) -> Ordering {
-        self.filename().cmp(other.filename())
-    }
 }
 
 impl<PP: Ord + FileOrd, P: Ord + FileOrd> Ord for UserError<PP, P> {
@@ -133,10 +125,9 @@ impl Naming {
 
     pub fn method_needs_visibility(first_token_p: Pos, name_p: Pos) -> Error {
         // Create a zero width position at the start of the first token.
-        let file = first_token_p.filename_rc();
         let mut p_span = first_token_p.to_raw_span();
         p_span.end = p_span.start;
-        let fix_pos = Pos::from_raw_span(file, p_span);
+        let fix_pos = Pos::from_raw_span(p_span);
 
         UserError::new(
             Self::MethodNeedsVisibility as isize,
diff --git a/hphp/hack/src/oxidized_by_ref/manual/pos.rs b/hphp/hack/src/oxidized_by_ref/manual/pos.rs
index b22f1419210..22476a61291 100644
--- a/hphp/hack/src/oxidized_by_ref/manual/pos.rs
+++ b/hphp/hack/src/oxidized_by_ref/manual/pos.rs
@@ -19,27 +19,19 @@ use oxidized::pos_span_tiny::PosSpanTiny;
 use serde::Deserialize;
 use serde::Serialize;
 
-use crate::relative_path::RelativePath;
-
 #[derive(Clone, Deserialize, Hash, Serialize, ToOcamlRep, FromOcamlRepIn)]
 enum PosImpl<'a> {
     Small {
-        #[serde(deserialize_with = "arena_deserializer::arena", borrow)]
-        file: &'a RelativePath<'a>,
         start: FilePosSmall,
         end: FilePosSmall,
     },
     Large {
-        #[serde(deserialize_with = "arena_deserializer::arena", borrow)]
-        file: &'a RelativePath<'a>,
         #[serde(deserialize_with = "arena_deserializer::arena", borrow)]
         start: &'a FilePosLarge,
         #[serde(deserialize_with = "arena_deserializer::arena", borrow)]
         end: &'a FilePosLarge,
     },
     Tiny {
-        #[serde(deserialize_with = "arena_deserializer::arena", borrow)]
-        file: &'a RelativePath<'a>,
         span: PosSpanTiny,
     },
 }
@@ -56,7 +48,6 @@ arena_deserializer::impl_deserialize_in_arena!(Pos<'arena>);
 impl arena_trait::TrivialDrop for Pos<'_> {}
 
 const NONE: Pos<'_> = Pos(Tiny {
-    file: RelativePath::empty(),
     span: PosSpanTiny::make_dummy(),
 });
 
@@ -67,24 +58,23 @@ impl<'a> Pos<'a> {
 
     pub fn is_none(&self) -> bool {
         match self {
-            Pos(PosImpl::Tiny { file, span }) => span.is_dummy() && file.is_empty(),
+            Pos(PosImpl::Tiny { span }) => span.is_dummy(),
             _ => false,
         }
     }
 
-    pub fn from_raw_span(b: &'a Bump, file: &'a RelativePath<'a>, span: PosSpanRaw) -> &'a Self {
+    pub fn from_raw_span(b: &'a Bump, span: PosSpanRaw) -> &'a Self {
         if let Some(span) = PosSpanTiny::make(&span.start, &span.end) {
-            return b.alloc(Pos(Tiny { file, span }));
+            return b.alloc(Pos(Tiny { span }));
         }
         let (lnum, bol, offset) = span.start.line_beg_offset();
         if let Some(start) = FilePosSmall::from_lnum_bol_offset(lnum, bol, offset) {
             let (lnum, bol, offset) = span.end.line_beg_offset();
             if let Some(end) = FilePosSmall::from_lnum_bol_offset(lnum, bol, offset) {
-                return b.alloc(Pos(Small { file, start, end }));
+                return b.alloc(Pos(Small { start, end }));
             }
         }
         b.alloc(Pos(Large {
-            file,
             start: b.alloc(span.start),
             end: b.alloc(span.end),
         }))
@@ -104,12 +94,6 @@ impl<'a> Pos<'a> {
         }
     }
 
-    pub fn filename(&self) -> &'a RelativePath<'a> {
-        match &self.0 {
-            Small { file, .. } | Large { file, .. } | Tiny { file, .. } => file,
-        }
-    }
-
     /// Returns a closed interval that's incorrect for multi-line spans.
     pub fn info_pos(&self) -> (usize, usize, usize) {
         fn compute<P: FilePos>(pos_start: P, pos_end: P) -> (usize, usize, usize) {
@@ -124,7 +108,7 @@ impl<'a> Pos<'a> {
             if start_minus1 == end {
                 end = start
             }
-            (line, start, end)
+            (line as usize, start as usize, end as usize)
         }
         match self.0 {
             Small { start, end, .. } => compute(start, end),
@@ -144,7 +128,12 @@ impl<'a> Pos<'a> {
             Tiny { span, .. } => span.to_raw_span().end.line_column_beg(),
         }
         .0;
-        (line_begin, line_end, start, end)
+        (
+            line_begin as usize,
+            line_end as usize,
+            start as usize,
+            end as usize,
+        )
     }
 
     pub fn info_raw(&self) -> (usize, usize) {
@@ -153,72 +142,75 @@ impl<'a> Pos<'a> {
 
     pub fn line(&self) -> usize {
         match self.0 {
-            Small { start, .. } => start.line(),
-            Large { start, .. } => start.line(),
-            Tiny { span, .. } => span.start_line_number(),
+            Small { start, .. } => start.line() as usize,
+            Large { start, .. } => start.line() as usize,
+            Tiny { span, .. } => span.start_line_number() as usize,
         }
     }
 
     pub fn from_lnum_bol_offset(
         b: &'a Bump,
-        file: &'a RelativePath<'a>,
         start: (usize, usize, usize),
         end: (usize, usize, usize),
     ) -> &'a Self {
         let (start_line, start_bol, start_offset) = start;
         let (end_line, end_bol, end_offset) = end;
-        let start = FilePosLarge::from_lnum_bol_offset(start_line, start_bol, start_offset);
-        let end = FilePosLarge::from_lnum_bol_offset(end_line, end_bol, end_offset);
-        Self::from_raw_span(b, file, PosSpanRaw { start, end })
+        let start = FilePosLarge::from_lnum_bol_offset(
+            start_line as u64,
+            start_bol as u64,
+            start_offset as u64,
+        );
+        let end =
+            FilePosLarge::from_lnum_bol_offset(end_line as u64, end_bol as u64, end_offset as u64);
+        Self::from_raw_span(b, PosSpanRaw { start, end })
     }
 
     pub fn to_start_and_end_lnum_bol_offset(
         &self,
     ) -> ((usize, usize, usize), (usize, usize, usize)) {
-        match &self.0 {
+        let (start, end) = match &self.0 {
             Small { start, end, .. } => (start.line_beg_offset(), end.line_beg_offset()),
             Large { start, end, .. } => (start.line_beg_offset(), end.line_beg_offset()),
             Tiny { span, .. } => {
                 let PosSpanRaw { start, end } = span.to_raw_span();
                 (start.line_beg_offset(), end.line_beg_offset())
             }
-        }
+        };
+
+        (
+            (start.0 as usize, start.1 as usize, start.2 as usize),
+            (end.0 as usize, end.1 as usize, end.2 as usize),
+        )
     }
 
     /// For single-line spans only.
     pub fn from_line_cols_offset(
         b: &'a Bump,
-        file: &'a RelativePath<'a>,
         line: usize,
         cols: Range<usize>,
         start_offset: usize,
     ) -> &'a Self {
-        let start = FilePosLarge::from_line_column_offset(line, cols.start, start_offset);
+        let start = FilePosLarge::from_line_column_offset(
+            line as u64,
+            cols.start as u64,
+            start_offset as u64,
+        );
         let end = FilePosLarge::from_line_column_offset(
-            line,
-            cols.end,
-            start_offset + (cols.end - cols.start),
+            line as u64,
+            cols.end as u64,
+            (start_offset + (cols.end - cols.start)) as u64,
         );
-        Self::from_raw_span(b, file, PosSpanRaw { start, end })
+        Self::from_raw_span(b, PosSpanRaw { start, end })
     }
 
     pub fn btw_nocheck(b: &'a Bump, x1: &'a Self, x2: &'a Self) -> &'a Self {
         let start = x1.to_raw_span().start;
         let end = x2.to_raw_span().end;
-        Self::from_raw_span(b, x1.filename(), PosSpanRaw { start, end })
+        Self::from_raw_span(b, PosSpanRaw { start, end })
     }
 
     pub fn btw(b: &'a Bump, x1: &'a Self, x2: &'a Self) -> Result<&'a Self, String> {
-        let file1 = x1.filename();
-        let file2 = x2.filename();
-        if !std::ptr::eq(file1, file2) && file1 != file2 {
-            // using string concatenation instead of format!,
-            // it is not stable see T52404885
-            Err(String::from("Position in separate files ")
-                + &x1.filename().to_string()
-                + " and "
-                + &x2.filename().to_string())
-        } else if x1.end_offset() > x2.end_offset() {
+        if x1.end_offset() > x2.end_offset() {
             Err(String::from("btw: invalid positions")
                 + &x1.end_offset().to_string()
                 + "and"
@@ -229,15 +221,6 @@ impl<'a> Pos<'a> {
     }
 
     pub fn merge(b: &'a Bump, x1: &'a Self, x2: &'a Self) -> Result<&'a Self, String> {
-        let file1 = x1.filename();
-        let file2 = x2.filename();
-        if !std::ptr::eq(file1, file2) && file1 != file2 {
-            // see comment above (T52404885)
-            return Err(String::from("Position in separate files ")
-                + &x1.filename().to_string()
-                + " and "
-                + &x2.filename().to_string());
-        }
         Ok(Self::merge_without_checking_filename(b, x1, x2))
     }
 
@@ -271,7 +254,7 @@ impl<'a> Pos<'a> {
             span1.end
         };
 
-        Self::from_raw_span(b, x1.filename(), PosSpanRaw { start, end })
+        Self::from_raw_span(b, PosSpanRaw { start, end })
     }
 
     pub fn last_char(&'a self, b: &'a Bump) -> &'a Self {
@@ -279,7 +262,7 @@ impl<'a> Pos<'a> {
             self
         } else {
             let end = self.to_raw_span().end;
-            Self::from_raw_span(b, self.filename(), PosSpanRaw { start: end, end })
+            Self::from_raw_span(b, PosSpanRaw { start: end, end })
         }
     }
 
@@ -288,53 +271,50 @@ impl<'a> Pos<'a> {
             self
         } else {
             let start = self.to_raw_span().start.with_column(0);
-            Self::from_raw_span(b, self.filename(), PosSpanRaw { start, end: start })
+            Self::from_raw_span(b, PosSpanRaw { start, end: start })
         }
     }
 
     pub fn end_offset(&self) -> usize {
         match &self.0 {
-            Small { end, .. } => end.offset(),
-            Large { end, .. } => end.offset(),
-            Tiny { span, .. } => span.end_offset(),
+            Small { end, .. } => end.offset() as usize,
+            Large { end, .. } => end.offset() as usize,
+            Tiny { span, .. } => span.end_offset() as usize,
         }
     }
 
     pub fn start_offset(&self) -> usize {
         match &self.0 {
-            Small { start, .. } => start.offset(),
-            Large { start, .. } => start.offset(),
-            Tiny { span, .. } => span.start_offset(),
+            Small { start, .. } => start.offset() as usize,
+            Large { start, .. } => start.offset() as usize,
+            Tiny { span, .. } => span.start_offset() as usize,
         }
     }
 
     pub fn to_owned(&self) -> oxidized::pos::Pos {
-        let file = self.filename();
         let PosSpanRaw { start, end } = self.to_raw_span();
+
+        let start = start.line_beg_offset();
+        let end = end.line_beg_offset();
         oxidized::pos::Pos::from_lnum_bol_offset(
-            ocamlrep::rc::RcOc::new(file.to_oxidized()),
-            start.line_beg_offset(),
-            end.line_beg_offset(),
+            (start.0 as usize, start.1 as usize, start.2 as usize),
+            (end.0 as usize, end.1 as usize, end.2 as usize),
         )
     }
 }
 
 impl<'a> Pos<'a> {
     pub fn from_oxidized_in(pos: &oxidized::pos::Pos, arena: &'a Bump) -> &'a Self {
-        let file = RelativePath::from_oxidized_in(pos.filename(), arena);
         let (start, end) = pos.to_start_and_end_lnum_bol_offset();
-        Self::from_lnum_bol_offset(arena, file, start, end)
+        Self::from_lnum_bol_offset(arena, start, end)
     }
 
     pub fn from_oxidized_with_file_in(
         pos: &oxidized::pos::Pos,
-        file: &'a RelativePath<'a>,
         arena: &'a Bump,
     ) -> &'a Self {
-        debug_assert!(pos.filename().prefix() == file.prefix());
-        debug_assert!(pos.filename().path() == file.path());
         let (start, end) = pos.to_start_and_end_lnum_bol_offset();
-        Self::from_lnum_bol_offset(arena, file, start, end)
+        Self::from_lnum_bol_offset(arena, start, end)
     }
 }
 
@@ -342,7 +322,6 @@ impl std::fmt::Debug for Pos<'_> {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         fn do_fmt<P: FilePos>(
             f: &mut std::fmt::Formatter<'_>,
-            file: &RelativePath<'_>,
             start: &P,
             end: &P,
         ) -> std::fmt::Result {
@@ -355,25 +334,21 @@ impl std::fmt::Debug for Pos<'_> {
             // positions. Depends upon RelativePath's implementation of Display
             // also being single-line.
             if start_line == end_line {
-                write!(
-                    f,
-                    "Pos({}, {}:{}-{})",
-                    &file, &start_line, &start_col, &end_col,
-                )
+                write!(f, "Pos({}:{}-{})", &start_line, &start_col, &end_col,)
             } else {
                 write!(
                     f,
-                    "Pos({}, {}:{}-{}:{})",
-                    &file, &start_line, &start_col, &end_line, &end_col,
+                    "Pos({}:{}-{}:{})",
+                    &start_line, &start_col, &end_line, &end_col,
                 )
             }
         }
         match &self.0 {
-            Small { file, start, end } => do_fmt(f, file, start, end),
-            Large { file, start, end } => do_fmt(f, file, *start, *end),
-            Tiny { file, span } => {
+            Small { start, end } => do_fmt(f, start, end),
+            Large { start, end } => do_fmt(f, *start, *end),
+            Tiny { span } => {
                 let PosSpanRaw { start, end } = span.to_raw_span();
-                do_fmt(f, file, &start, &end)
+                do_fmt(f, &start, &end)
             }
         }
     }
@@ -383,11 +358,9 @@ impl std::fmt::Display for Pos<'_> {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         fn do_fmt<P: FilePos>(
             f: &mut std::fmt::Formatter<'_>,
-            file: &RelativePath<'_>,
             start: P,
             end: P,
         ) -> std::fmt::Result {
-            write!(f, "{}", file)?;
             let (start_line, start_col, _) = start.line_column_beg();
             let (end_line, end_col, _) = end.line_column_beg();
             if start_line == end_line {
@@ -397,11 +370,11 @@ impl std::fmt::Display for Pos<'_> {
             }
         }
         match self.0 {
-            Small { file, start, end } => do_fmt(f, file, start, end),
-            Large { file, start, end } => do_fmt(f, file, *start, *end),
-            Tiny { file, span } => {
+            Small { start, end } => do_fmt(f, start, end),
+            Large { start, end } => do_fmt(f, *start, *end),
+            Tiny { span } => {
                 let PosSpanRaw { start, end } = span.to_raw_span();
-                do_fmt(f, file, start, end)
+                do_fmt(f, start, end)
             }
         }
     }
@@ -410,9 +383,8 @@ impl std::fmt::Display for Pos<'_> {
 impl Ord for Pos<'_> {
     // Intended to match the implementation of `Pos.compare` in OCaml.
     fn cmp(&self, other: &Pos<'_>) -> Ordering {
-        self.filename()
-            .cmp(other.filename())
-            .then(self.start_offset().cmp(&other.start_offset()))
+        self.start_offset()
+            .cmp(&other.start_offset())
             .then(self.end_offset().cmp(&other.end_offset()))
     }
 }
@@ -455,14 +427,7 @@ pub struct PosString<'a>(&'a Pos<'a>);
 impl std::fmt::Display for PosString<'_> {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         let (line, start, end) = self.0.info_pos();
-        write!(
-            f,
-            "File {:?}, line {}, characters {}-{}:",
-            self.0.filename().path(),
-            line,
-            start,
-            end
-        )
+        write!(f, "line {}, characters {}-{}:", line, start, end)
     }
 }
 
@@ -484,112 +449,18 @@ mod tests {
 
     fn make_pos<'a>(
         b: &'a Bump,
-        name: &'a RelativePath<'a>,
         start: (usize, usize, usize),
         end: (usize, usize, usize),
     ) -> &'a Pos<'a> {
-        b.alloc(Pos::from_lnum_bol_offset(b, name, start, end))
+        b.alloc(Pos::from_lnum_bol_offset(b, start, end))
     }
 
     #[test]
     fn test_pos_is_none() {
         let b = Bump::new();
         assert!(Pos::none().is_none());
-        let path_a = b.alloc(RelativePath::make(Prefix::Dummy, "a"));
-        assert!(!Pos::from_lnum_bol_offset(&b, path_a, (0, 0, 0), (0, 0, 0)).is_none());
-        let empty_path = b.alloc(RelativePath::make(Prefix::Dummy, ""));
-        assert!(!Pos::from_lnum_bol_offset(&b, empty_path, (1, 0, 0), (0, 0, 0)).is_none());
-    }
-
-    #[test]
-    fn test_pos_string() {
-        assert_eq!(
-            Pos::none().string().to_string(),
-            r#"File "", line 0, characters 0-0:"#
-        );
-        let b = Bump::new();
-        let path = b.alloc(RelativePath::make(Prefix::Dummy, "a.php"));
-        assert_eq!(
-            Pos::from_lnum_bol_offset(&b, path, (5, 100, 117), (5, 100, 142))
-                .string()
-                .to_string(),
-            r#"File "a.php", line 5, characters 18-42:"#
-        );
-    }
-
-    #[test]
-    fn test_pos_merge() {
-        let b = Bump::new();
-        let test = |name, (exp_start, exp_end), ((fst_start, fst_end), (snd_start, snd_end))| {
-            let path = b.alloc(RelativePath::make(Prefix::Dummy, "a"));
-            assert_eq!(
-                Ok(make_pos(&b, path, exp_start, exp_end)),
-                Pos::merge(
-                    &b,
-                    make_pos(&b, path, fst_start, fst_end),
-                    make_pos(&b, path, snd_start, snd_end)
-                ),
-                "{}",
-                name
-            );
-
-            // Run this again because we want to test that we get the same
-            // result regardless of order.
-            assert_eq!(
-                Ok(make_pos(&b, path, exp_start, exp_end)),
-                Pos::merge(
-                    &b,
-                    make_pos(&b, path, snd_start, snd_end),
-                    make_pos(&b, path, fst_start, fst_end),
-                ),
-                "{} (reversed)",
-                name
-            );
-        };
-
-        test(
-            "basic test",
-            ((0, 0, 0), (0, 0, 5)),
-            (((0, 0, 0), (0, 0, 2)), ((0, 0, 2), (0, 0, 5))),
-        );
-
-        test(
-            "merge should work with gaps",
-            ((0, 0, 0), (0, 0, 15)),
-            (((0, 0, 0), (0, 0, 5)), ((0, 0, 10), (0, 0, 15))),
-        );
-
-        test(
-            "merge should work with overlaps",
-            ((0, 0, 0), (0, 0, 15)),
-            (((0, 0, 0), (0, 0, 12)), ((0, 0, 7), (0, 0, 15))),
-        );
-
-        test(
-            "merge should work between lines",
-            ((0, 0, 0), (2, 20, 25)),
-            (((0, 0, 0), (1, 10, 15)), ((1, 10, 20), (2, 20, 25))),
-        );
-
-        assert_eq!(
-            Err("Position in separate files |a and |b".to_string()),
-            Pos::merge(
-                &b,
-                make_pos(
-                    &b,
-                    &RelativePath::make(Prefix::Dummy, "a"),
-                    (0, 0, 0),
-                    (0, 0, 0)
-                ),
-                make_pos(
-                    &b,
-                    &RelativePath::make(Prefix::Dummy, "b"),
-                    (0, 0, 0),
-                    (0, 0, 0)
-                )
-            ),
-            "should reject merges with different filenames"
-        );
+        assert!(!Pos::from_lnum_bol_offset(&b, (0, 0, 0), (0, 0, 0)).is_none());
+        assert!(!Pos::from_lnum_bol_offset(&b, (1, 0, 0), (0, 0, 0)).is_none());
     }
 
     #[test]
@@ -599,7 +470,7 @@ mod tests {
         let b = &bumpalo::Bump::new();
         let hash = no_pos_hash::position_insensitive_hash;
         let none = Pos::none();
-        let pos = Pos::from_line_cols_offset(b, RelativePath::empty(), 2, 2..10, 17);
+        let pos = Pos::from_line_cols_offset(b, 2, 2..10, 17);
 
         assert_eq!(hash(&Id(pos, "foo")), hash(&Id(pos, "foo")));
         assert_eq!(hash(&Id(none, "foo")), hash(&Id(pos, "foo")));
diff --git a/hphp/hack/src/parser/aast_parser.rs b/hphp/hack/src/parser/aast_parser.rs
index 6bae7308653..9db0c19f5e1 100644
--- a/hphp/hack/src/parser/aast_parser.rs
+++ b/hphp/hack/src/parser/aast_parser.rs
@@ -78,11 +78,11 @@ impl<'src> AastParser {
         ns: RcOc<NamespaceEnv>,
         indexed_source_text: &'src IndexedSourceText<'src>,
     ) -> Result<ParserResult> {
-        let start_t = Instant::now();
+        //let start_t = Instant::now();
         let arena = Bump::new();
         stack_limit::reset();
         let (language, mode, tree) = Self::parse_text(&arena, env, indexed_source_text)?;
-        let parsing_t = start_t.elapsed();
+        //let parsing_t = start_t.elapsed();
         let parse_peak = stack_limit::peak();
         let mut pr = Self::from_tree_with_namespace_env(
             env,
@@ -95,8 +95,8 @@ impl<'src> AastParser {
         )?;
 
         pr.profile.parse_peak = parse_peak as u64;
-        pr.profile.parsing_t = parsing_t;
-        pr.profile.total_t = start_t.elapsed();
+        //pr.profile.parsing_t = parsing_t;
+        //pr.profile.total_t = start_t.elapsed();
         Ok(pr)
     }
 
@@ -133,7 +133,7 @@ impl<'src> AastParser {
         mode: Option<Mode>,
         tree: PositionedSyntaxTree<'src, 'arena>,
     ) -> Result<ParserResult> {
-        let lowering_t = Instant::now();
+        //let lowering_t = Instant::now();
         match language {
             Language::Hack => {}
             _ => return Err(Error::NotAHackFile()),
@@ -155,14 +155,14 @@ impl<'src> AastParser {
         );
         stack_limit::reset();
         let ret = lower(&mut lowerer_env, tree.root());
-        let (lowering_t, elaboration_t) = (lowering_t.elapsed(), Instant::now());
+        //let (lowering_t, elaboration_t) = (lowering_t.elapsed(), Instant::now());
         let lower_peak = stack_limit::peak() as u64;
         let mut ret = if env.elaborate_namespaces {
             namespaces::toplevel_elaborator::elaborate_toplevel_defs(ns, ret)
         } else {
             ret
         };
-        let (elaboration_t, error_t) = (elaboration_t.elapsed(), Instant::now());
+        //let (elaboration_t, error_t) = (elaboration_t.elapsed(), Instant::now());
         stack_limit::reset();
         let syntax_errors =
             Self::check_syntax_error(env, indexed_source_text, &tree, Some(&mut ret));
@@ -170,7 +170,7 @@ impl<'src> AastParser {
         let lowerer_parsing_errors = lowerer_env.parsing_errors().borrow().to_vec();
         let errors = lowerer_env.hh_errors().borrow().to_vec();
         let lint_errors = lowerer_env.lint_errors().borrow().to_vec();
-        let error_t = error_t.elapsed();
+        //let error_t = error_t.elapsed();
 
         Ok(ParserResult {
             file_mode: mode,
@@ -182,9 +182,9 @@ impl<'src> AastParser {
             lint_errors,
             profile: ParserProfile {
                 lower_peak,
-                lowering_t,
-                elaboration_t,
-                error_t,
+                lowering_t: std::time::Duration::new(0, 0),
+                elaboration_t: std::time::Duration::new(0, 0),
+                error_t: std::time::Duration::new(0, 0),
                 error_peak,
                 arena_bytes: arena.allocated_bytes() as u64,
                 ..Default::default()
@@ -315,7 +315,7 @@ impl<'src> AastParser {
                     disable_hh_ignore_error: env.parser_options.po_disable_hh_ignore_error,
                     allowed_decl_fixme_codes: &env.parser_options.po_allowed_decl_fixme_codes,
                 };
-            Ok(scourer.scour_comments(script))
+            Ok(scourer.scour_comments(script, indexed_source_text.source_text().file_path()))
         } else {
             Ok(ScouredComments {
                 comments: Default::default(),
diff --git a/hphp/hack/src/parser/core/lexer.rs b/hphp/hack/src/parser/core/lexer.rs
index 8db2f3a3271..cadcc02dbbf 100644
--- a/hphp/hack/src/parser/core/lexer.rs
+++ b/hphp/hack/src/parser/core/lexer.rs
@@ -1979,7 +1979,7 @@ where
                         acc.push(t);
                         return acc;
                     }
-                    TriviaKind::FixMe | TriviaKind::IgnoreError => {
+                    TriviaKind::FixMe | TriviaKind::IgnoreError | TriviaKind::DelimitedComment => {
                         return acc;
                     }
                     _ => {
diff --git a/hphp/hack/src/parser/lowerer/lowerer.rs b/hphp/hack/src/parser/lowerer/lowerer.rs
index aa0f67fac65..bf35cfee079 100644
--- a/hphp/hack/src/parser/lowerer/lowerer.rs
+++ b/hphp/hack/src/parser/lowerer/lowerer.rs
@@ -3443,12 +3443,12 @@ fn p_markup<'a>(node: S<'a>, env: &mut Env<'a>) -> Result<ast::Stmt> {
             let markup_hashbang = &c.hashbang;
             let markup_suffix = &c.suffix;
             let pos = p_pos(node, env);
-            let f = pos.filename();
             let expected_suffix_offset = if markup_hashbang.is_missing() {
                 0
             } else {
                 markup_hashbang.width() + 1 /* for newline */
             };
+            let f = env.source_text().file_path();
             if (f.has_extension("hack") || f.has_extension("hackpartial"))
                 && !(markup_suffix.is_missing())
             {
diff --git a/hphp/hack/src/parser/lowerer/scour_comment.rs b/hphp/hack/src/parser/lowerer/scour_comment.rs
index 9bb0c19f13f..687e3a002fd 100644
--- a/hphp/hack/src/parser/lowerer/scour_comment.rs
+++ b/hphp/hack/src/parser/lowerer/scour_comment.rs
@@ -17,6 +17,7 @@ use parser_core_types::syntax_by_ref::syntax_variant_generated::SyntaxVariant::*
 use parser_core_types::syntax_trait::SyntaxTrait;
 use parser_core_types::trivia_kind::TriviaKind;
 use regex::bytes::Regex;
+use relative_path::RelativePath;
 use rescan_trivia::RescanTrivia;
 
 /** The full fidelity parser considers all comments "simply" trivia. Some
@@ -42,7 +43,11 @@ where
     V: 'arena,
     Syntax<'arena, T, V>: SyntaxTrait,
 {
-    pub fn scour_comments<'r>(&self, top_node: &'r Syntax<'arena, T, V>) -> ScouredComments
+    pub fn scour_comments<'r>(
+        &self,
+        top_node: &'r Syntax<'arena, T, V>,
+        file_path: &RelativePath,
+    ) -> ScouredComments
     where
         'r: 'arena,
     {
@@ -64,7 +69,7 @@ where
                         let leading = t.scan_leading(self.source_text());
                         let trailing = t.scan_trailing(self.source_text());
                         for tr in leading.iter().chain(trailing.iter()) {
-                            self.on_trivia(in_block, node, tr, &mut acc);
+                            self.on_trivia(in_block, node, tr, &mut acc, file_path);
                         }
                     }
                     continue;
@@ -85,6 +90,7 @@ where
         node: &Syntax<'arena, T, V>,
         t: &PositionedTrivium,
         acc: &mut ScouredComments,
+        file_path: &RelativePath,
     ) {
         use relative_path::Prefix;
         use TriviaKind::*;
@@ -130,7 +136,7 @@ where
                         Some(code) => {
                             let code = std::str::from_utf8(code).unwrap();
                             let code: isize = std::str::FromStr::from_str(code).unwrap();
-                            let in_hhi = pos.filename().prefix() == Prefix::Hhi;
+                            let in_hhi = file_path.prefix() == Prefix::Hhi;
                             if !(in_block
                                 || in_hhi
                                 || self.allowed_decl_fixme_codes.contains(&code))
diff --git a/hphp/hack/src/utils/hh24_types/hh24_types.rs b/hphp/hack/src/utils/hh24_types/hh24_types.rs
index 0febd35fe7d..4fd8c642cac 100644
--- a/hphp/hack/src/utils/hh24_types/hh24_types.rs
+++ b/hphp/hack/src/utils/hh24_types/hh24_types.rs
@@ -32,12 +32,14 @@ macro_rules! u64_hash_wrapper_impls {
             }
         }
 
+        #[cfg(unix)]
         impl rusqlite::ToSql for $name {
             fn to_sql(&self) -> rusqlite::Result<rusqlite::types::ToSqlOutput<'_>> {
                 Ok(rusqlite::types::ToSqlOutput::from(self.0 as i64))
             }
         }
 
+        #[cfg(unix)]
         impl rusqlite::types::FromSql for $name {
             fn column_result(
                 value: rusqlite::types::ValueRef<'_>,
diff --git a/hphp/hack/src/utils/rust/pos/file_pos.rs b/hphp/hack/src/utils/rust/pos/file_pos.rs
index fff34e9c159..49ae1121f9c 100644
--- a/hphp/hack/src/utils/rust/pos/file_pos.rs
+++ b/hphp/hack/src/utils/rust/pos/file_pos.rs
@@ -4,6 +4,6 @@
 // LICENSE file in the "hack" directory of this source tree.
 
 pub trait FilePos {
-    fn offset(&self) -> usize;
-    fn line_column_beg(&self) -> (usize, usize, usize);
+    fn offset(&self) -> u64;
+    fn line_column_beg(&self) -> (u64, u64, u64);
 }
diff --git a/hphp/hack/src/utils/rust/pos/file_pos_large.rs b/hphp/hack/src/utils/rust/pos/file_pos_large.rs
index f59e0a024cc..a1929b265f5 100644
--- a/hphp/hack/src/utils/rust/pos/file_pos_large.rs
+++ b/hphp/hack/src/utils/rust/pos/file_pos_large.rs
@@ -15,13 +15,13 @@ use crate::file_pos_small::FilePosSmall;
 #[derive(Copy, Clone, Debug, Deserialize, Eq, Hash, PartialEq, Serialize)]
 pub struct FilePosLarge {
     /// line number. Starts at 1.
-    lnum: usize,
+    lnum: u64,
     /// character number of the beginning of line of this position.
     /// The column number is therefore offset - bol
     /// Starts at 0
-    bol: usize,
+    bol: u64,
     /// character offset from the beginning of the file. Starts at 0.
-    offset: usize,
+    offset: u64,
 }
 arena_deserializer::impl_deserialize_in_arena!(FilePosLarge);
 
@@ -30,7 +30,7 @@ impl arena_trait::TrivialDrop for FilePosLarge {}
 const DUMMY: FilePosLarge = FilePosLarge {
     lnum: 0,
     bol: 0,
-    offset: usize::max_value(),
+    offset: u64::max_value(),
 };
 
 impl FilePosLarge {
@@ -56,7 +56,7 @@ impl FilePosLarge {
     // constructors
 
     #[inline]
-    pub const fn from_line_column_offset(line: usize, column: usize, offset: usize) -> Self {
+    pub const fn from_line_column_offset(line: u64, column: u64, offset: u64) -> Self {
         FilePosLarge {
             lnum: line,
             bol: offset - column,
@@ -65,29 +65,29 @@ impl FilePosLarge {
     }
 
     #[inline]
-    pub const fn from_lnum_bol_offset(lnum: usize, bol: usize, offset: usize) -> Self {
+    pub const fn from_lnum_bol_offset(lnum: u64, bol: u64, offset: u64) -> Self {
         FilePosLarge { lnum, bol, offset }
     }
 
     // accessors
 
     #[inline]
-    pub const fn line(self) -> usize {
+    pub const fn line(self) -> u64 {
         self.lnum
     }
 
     #[inline]
-    pub const fn column(self) -> usize {
+    pub fn column(self) -> u64 {
         self.offset - self.bol
     }
 
     #[inline]
-    pub const fn beg_of_line(self) -> usize {
+    pub const fn beg_of_line(self) -> u64 {
         self.bol
     }
 
     #[inline]
-    pub const fn with_column(self, col: usize) -> Self {
+    pub const fn with_column(self, col: u64) -> Self {
         FilePosLarge {
             lnum: self.lnum,
             bol: self.bol,
@@ -96,34 +96,34 @@ impl FilePosLarge {
     }
 
     #[inline]
-    pub const fn line_beg(self) -> (usize, usize) {
+    pub const fn line_beg(self) -> (u64, u64) {
         (self.lnum, self.bol)
     }
 
     #[inline]
-    pub const fn line_column(self) -> (usize, usize) {
+    pub const fn line_column(self) -> (u64, u64) {
         (self.lnum, self.offset - self.bol)
     }
 
     #[inline]
-    pub const fn line_column_offset(self) -> (usize, usize, usize) {
+    pub const fn line_column_offset(self) -> (u64, u64, u64) {
         (self.lnum, self.offset - self.bol, self.offset)
     }
 
     #[inline]
-    pub const fn line_beg_offset(self) -> (usize, usize, usize) {
+    pub const fn line_beg_offset(self) -> (u64, u64, u64) {
         (self.lnum, self.bol, self.offset)
     }
 }
 
 impl FilePos for FilePosLarge {
     #[inline]
-    fn offset(&self) -> usize {
+    fn offset(&self) -> u64 {
         self.offset
     }
 
     #[inline]
-    fn line_column_beg(&self) -> (usize, usize, usize) {
+    fn line_column_beg(&self) -> (u64, u64, u64) {
         (self.lnum, self.offset - self.bol, self.bol)
     }
 }
@@ -166,7 +166,7 @@ impl FromOcamlRep for FilePosLarge {
         Ok(Self {
             lnum,
             bol,
-            offset: offset as usize,
+            offset: offset as u64,
         })
     }
 }
diff --git a/hphp/hack/src/utils/rust/pos/file_pos_small.rs b/hphp/hack/src/utils/rust/pos/file_pos_small.rs
index ce3bd4e0172..66579bfceab 100644
--- a/hphp/hack/src/utils/rust/pos/file_pos_small.rs
+++ b/hphp/hack/src/utils/rust/pos/file_pos_small.rs
@@ -38,23 +38,23 @@ arena_deserializer::impl_deserialize_in_arena!(FilePosSmall);
 
 impl arena_trait::TrivialDrop for FilePosSmall {}
 
-const COLUMN_BITS: usize = 9;
-const LINE_BITS: usize = 24;
-const BOL_BITS: usize = 30;
+const COLUMN_BITS: u64 = 9;
+const LINE_BITS: u64 = 24;
+const BOL_BITS: u64 = 30;
 
 #[inline]
-const fn mask(bits: usize) -> usize {
+const fn mask(bits: u64) -> u64 {
     (1 << bits) - 1
 }
 
 #[inline]
-const fn mask_by(bits: usize, x: u64) -> usize {
-    (x & (mask(bits) as u64)) as usize
+const fn mask_by(bits: u64, x: u64) -> u64 {
+    x & mask(bits)
 }
 
-const MAX_COLUMN: usize = mask(COLUMN_BITS);
-const MAX_LINE: usize = mask(LINE_BITS);
-const MAX_BOL: usize = mask(BOL_BITS);
+const MAX_COLUMN: u64 = mask(COLUMN_BITS);
+const MAX_LINE: u64 = mask(LINE_BITS);
+const MAX_BOL: u64 = mask(BOL_BITS);
 
 const DUMMY: u64 = u64::max_value();
 
@@ -70,7 +70,7 @@ impl FilePosSmall {
     }
 
     #[inline]
-    pub fn beg_of_line(self) -> usize {
+    pub fn beg_of_line(self) -> u64 {
         if self.is_dummy() {
             0
         } else {
@@ -79,7 +79,7 @@ impl FilePosSmall {
     }
 
     #[inline]
-    pub fn line(self) -> usize {
+    pub fn line(self) -> u64 {
         if self.is_dummy() {
             0
         } else {
@@ -88,25 +88,25 @@ impl FilePosSmall {
     }
 
     #[inline]
-    pub fn column(self) -> usize {
+    pub fn column(self) -> u64 {
         if self.is_dummy() {
-            DUMMY as usize
+            DUMMY
         } else {
             mask_by(COLUMN_BITS, self.0)
         }
     }
 
     #[inline]
-    const fn bol_line_col_unchecked(bol: usize, line: usize, col: usize) -> Self {
+    const fn bol_line_col_unchecked(bol: u64, line: u64, col: u64) -> Self {
         FilePosSmall(
-            ((bol as u64) << (COLUMN_BITS + LINE_BITS))
-                + ((line as u64) << COLUMN_BITS)
-                + (col as u64),
+            (bol << (COLUMN_BITS + LINE_BITS))
+                + (line << COLUMN_BITS)
+                + col,
         )
     }
 
     #[inline]
-    fn bol_line_col(bol: usize, line: usize, col: usize) -> Option<Self> {
+    fn bol_line_col(bol: u64, line: u64, col: u64) -> Option<Self> {
         if col > MAX_COLUMN || line > MAX_LINE || bol > MAX_BOL {
             None
         } else {
@@ -122,39 +122,39 @@ impl FilePosSmall {
     // constructors
 
     #[inline]
-    pub fn from_line_column_offset(line: usize, column: usize, offset: usize) -> Option<Self> {
+    pub fn from_line_column_offset(line: u64, column: u64, offset: u64) -> Option<Self> {
         Self::bol_line_col(offset - column, line, column)
     }
 
     #[inline]
-    pub fn from_lnum_bol_offset(lnum: usize, bol: usize, offset: usize) -> Option<Self> {
+    pub fn from_lnum_bol_offset(lnum: u64, bol: u64, offset: u64) -> Option<Self> {
         Self::bol_line_col(bol, lnum, offset - bol)
     }
 
     // accessors
 
     #[inline]
-    pub fn line_beg(self) -> (usize, usize) {
+    pub fn line_beg(self) -> (u64, u64) {
         (self.line(), self.beg_of_line())
     }
 
     #[inline]
-    pub fn line_column(self) -> (usize, usize) {
+    pub fn line_column(self) -> (u64, u64) {
         (self.line(), self.column())
     }
 
     #[inline]
-    pub fn line_column_offset(self) -> (usize, usize, usize) {
+    pub fn line_column_offset(self) -> (u64, u64, u64) {
         (self.line(), self.column(), self.offset())
     }
 
     #[inline]
-    pub fn line_beg_offset(self) -> (usize, usize, usize) {
+    pub fn line_beg_offset(self) -> (u64, u64, u64) {
         (self.line(), self.beg_of_line(), self.offset())
     }
 
     #[inline]
-    pub fn with_column(self, col: usize) -> Self {
+    pub fn with_column(self, col: u64) -> Self {
         match Self::bol_line_col(self.beg_of_line(), self.line(), col) {
             None => FilePosSmall(DUMMY),
             Some(pos) => pos,
@@ -164,12 +164,12 @@ impl FilePosSmall {
 
 impl FilePos for FilePosSmall {
     #[inline]
-    fn offset(&self) -> usize {
+    fn offset(&self) -> u64 {
         self.beg_of_line() + self.column()
     }
 
     #[inline]
-    fn line_column_beg(&self) -> (usize, usize, usize) {
+    fn line_column_beg(&self) -> (u64, u64, u64) {
         (self.line(), self.column(), self.beg_of_line())
     }
 }
diff --git a/hphp/hack/src/utils/rust/pos/pos_impl.rs b/hphp/hack/src/utils/rust/pos/pos_impl.rs
index 906d029a122..b58ac7fb7c7 100644
--- a/hphp/hack/src/utils/rust/pos/pos_impl.rs
+++ b/hphp/hack/src/utils/rust/pos/pos_impl.rs
@@ -8,10 +8,8 @@ use std::cmp::Ordering;
 use std::ops::Range;
 
 use eq_modulo_pos::EqModuloPos;
-use ocamlrep::rc::RcOc;
 use ocamlrep::FromOcamlRep;
 use ocamlrep::ToOcamlRep;
-use relative_path::RelativePath;
 use relative_path::RelativePathCtx;
 use serde::Deserialize;
 use serde::Serialize;
@@ -25,19 +23,14 @@ use crate::pos_span_tiny::PosSpanTiny;
 #[derive(Clone, Deserialize, Hash, Serialize)]
 enum PosImpl {
     Small {
-        file: RcOc<RelativePath>,
         start: FilePosSmall,
         end: FilePosSmall,
     },
     Large {
-        file: RcOc<RelativePath>,
         start: Box<FilePosLarge>,
         end: Box<FilePosLarge>,
     },
     Tiny {
-        /// Representation invariant: `RelativePath::EMPTY` is always encoded as
-        /// `None`. This allows us to construct `Pos` in `const` contexts.
-        file: Option<RcOc<RelativePath>>,
         span: PosSpanTiny,
     },
     FromReason(Box<PosImpl>),
@@ -50,13 +43,12 @@ pub type PosR<'a> = &'a Pos;
 
 impl Pos {
     pub const NONE: Self = Self(PosImpl::Tiny {
-        file: None,
         span: PosSpanTiny::make_dummy(),
     });
 
     pub fn is_none(&self) -> bool {
         match self {
-            Pos(PosImpl::Tiny { file, span }) => span.is_dummy() && file.is_none(),
+            Pos(PosImpl::Tiny { span }) => span.is_dummy(),
             _ => false,
         }
     }
@@ -67,10 +59,9 @@ impl Pos {
         line0 != 1 || char0 != 1 || line1 != 1 || char1 != 1
     }
 
-    pub fn from_raw_span(file: RcOc<RelativePath>, span: PosSpanRaw) -> Self {
+    pub fn from_raw_span(span: PosSpanRaw) -> Self {
         if let Some(span) = PosSpanTiny::make(&span.start, &span.end) {
             return Pos(PosImpl::Tiny {
-                file: if file.is_empty() { None } else { Some(file) },
                 span,
             });
         }
@@ -78,11 +69,10 @@ impl Pos {
         if let Some(start) = FilePosSmall::from_lnum_bol_offset(lnum, bol, offset) {
             let (lnum, bol, offset) = span.end.line_beg_offset();
             if let Some(end) = FilePosSmall::from_lnum_bol_offset(lnum, bol, offset) {
-                return Pos(PosImpl::Small { file, start, end });
+                return Pos(PosImpl::Small { start, end });
             }
         }
         Pos(PosImpl::Large {
-            file,
             start: Box::new(span.start),
             end: Box::new(span.end),
         })
@@ -103,42 +93,6 @@ impl Pos {
         }
     }
 
-    pub fn filename(&self) -> &RelativePath {
-        match &self.0 {
-            PosImpl::Small { file, .. }
-            | PosImpl::Large { file, .. }
-            | PosImpl::Tiny {
-                file: Some(file), ..
-            } => file,
-            PosImpl::Tiny { file: None, .. } => &RelativePath::EMPTY,
-            PosImpl::FromReason(_p) => unimplemented!(),
-        }
-    }
-
-    pub fn filename_rc(&self) -> RcOc<RelativePath> {
-        match &self.0 {
-            PosImpl::Small { file, .. }
-            | PosImpl::Large { file, .. }
-            | PosImpl::Tiny {
-                file: Some(file), ..
-            } => RcOc::clone(file),
-            PosImpl::Tiny { file: None, .. } => RcOc::new(RelativePath::EMPTY),
-            PosImpl::FromReason(_p) => unimplemented!(),
-        }
-    }
-
-    fn into_filename(self) -> RcOc<RelativePath> {
-        match self.0 {
-            PosImpl::Small { file, .. }
-            | PosImpl::Large { file, .. }
-            | PosImpl::Tiny {
-                file: Some(file), ..
-            } => file,
-            PosImpl::Tiny { file: None, .. } => RcOc::new(RelativePath::EMPTY),
-            PosImpl::FromReason(_p) => unimplemented!(),
-        }
-    }
-
     /// Returns a closed interval that's incorrect for multi-line spans.
     pub fn info_pos(&self) -> (usize, usize, usize) {
         fn compute<P: FilePos>(pos_start: &P, pos_end: &P) -> (usize, usize, usize) {
@@ -153,7 +107,7 @@ impl Pos {
             if end == start_minus1 {
                 end = start
             }
-            (line, start, end)
+            (line as usize, start as usize, end as usize)
         }
         match &self.0 {
             PosImpl::Small { start, end, .. } => compute(start, end),
@@ -175,7 +129,7 @@ impl Pos {
             PosImpl::FromReason(_p) => unimplemented!(),
         }
         .0;
-        (line_begin, line_end, start, end)
+        (line_begin, line_end as usize, start, end)
     }
 
     pub fn info_raw(&self) -> (usize, usize) {
@@ -184,29 +138,30 @@ impl Pos {
 
     pub fn line(&self) -> usize {
         match &self.0 {
-            PosImpl::Small { start, .. } => start.line(),
-            PosImpl::Large { start, .. } => start.line(),
-            PosImpl::Tiny { span, .. } => span.start_line_number(),
+            PosImpl::Small { start, .. } => start.line() as usize,
+            PosImpl::Large { start, .. } => start.line() as usize,
+            PosImpl::Tiny { span, .. } => span.start_line_number() as usize,
             PosImpl::FromReason(_p) => unimplemented!(),
         }
     }
 
-    pub fn from_lnum_bol_offset(
-        file: RcOc<RelativePath>,
-        start: (usize, usize, usize),
-        end: (usize, usize, usize),
-    ) -> Self {
+    pub fn from_lnum_bol_offset(start: (usize, usize, usize), end: (usize, usize, usize)) -> Self {
         let (start_line, start_bol, start_offset) = start;
         let (end_line, end_bol, end_offset) = end;
-        let start = FilePosLarge::from_lnum_bol_offset(start_line, start_bol, start_offset);
-        let end = FilePosLarge::from_lnum_bol_offset(end_line, end_bol, end_offset);
-        Self::from_raw_span(file, PosSpanRaw { start, end })
+        let start = FilePosLarge::from_lnum_bol_offset(
+            start_line as u64,
+            start_bol as u64,
+            start_offset as u64,
+        );
+        let end =
+            FilePosLarge::from_lnum_bol_offset(end_line as u64, end_bol as u64, end_offset as u64);
+        Self::from_raw_span(PosSpanRaw { start, end })
     }
 
     pub fn to_start_and_end_lnum_bol_offset(
         &self,
     ) -> ((usize, usize, usize), (usize, usize, usize)) {
-        match &self.0 {
+        let (start, end) = match &self.0 {
             PosImpl::Small { start, end, .. } => (start.line_beg_offset(), end.line_beg_offset()),
             PosImpl::Large { start, end, .. } => (start.line_beg_offset(), end.line_beg_offset()),
             PosImpl::Tiny { span, .. } => {
@@ -214,40 +169,41 @@ impl Pos {
                 (start.line_beg_offset(), end.line_beg_offset())
             }
             PosImpl::FromReason(_p) => unimplemented!(),
-        }
+        };
+
+        (
+            (start.0 as usize, start.1 as usize, start.2 as usize),
+            (end.0 as usize, end.1 as usize, end.2 as usize),
+        )
     }
 
     /// For single-line spans only.
     pub fn from_line_cols_offset(
-        file: RcOc<RelativePath>,
         line: usize,
         cols: Range<usize>,
         start_offset: usize,
     ) -> Self {
-        let start = FilePosLarge::from_line_column_offset(line, cols.start, start_offset);
+        let start = FilePosLarge::from_line_column_offset(
+            line as u64,
+            cols.start as u64,
+            start_offset as u64,
+        );
         let end = FilePosLarge::from_line_column_offset(
-            line,
-            cols.end,
-            start_offset + (cols.end - cols.start),
+            line as u64,
+            cols.end as u64,
+            (start_offset + (cols.end - cols.start)) as u64,
         );
-        Self::from_raw_span(file, PosSpanRaw { start, end })
+        Self::from_raw_span(PosSpanRaw { start, end })
     }
 
     pub fn btw_nocheck(x1: Self, x2: Self) -> Self {
         let start = x1.to_raw_span().start;
         let end = x2.to_raw_span().end;
-        Self::from_raw_span(x1.into_filename(), PosSpanRaw { start, end })
+        Self::from_raw_span(PosSpanRaw { start, end })
     }
 
     pub fn btw(x1: &Self, x2: &Self) -> Result<Self, String> {
-        if x1.filename() != x2.filename() {
-            // using string concatenation instead of format!,
-            // it is not stable see T52404885
-            Err(String::from("Position in separate files ")
-                + &x1.filename().to_string()
-                + " and "
-                + &x2.filename().to_string())
-        } else if x1.end_offset() > x2.end_offset() {
+        if x1.end_offset() > x2.end_offset() {
             Err(String::from("btw: invalid positions")
                 + &x1.end_offset().to_string()
                 + "and"
@@ -258,14 +214,6 @@ impl Pos {
     }
 
     pub fn merge(x1: &Self, x2: &Self) -> Result<Self, String> {
-        if x1.filename() != x2.filename() {
-            // see comment above (T52404885)
-            return Err(String::from("Position in separate files ")
-                + &x1.filename().to_string()
-                + " and "
-                + &x2.filename().to_string());
-        }
-
         let span1 = x1.to_raw_span();
         let span2 = x2.to_raw_span();
 
@@ -285,10 +233,7 @@ impl Pos {
             span2.end
         };
 
-        Ok(Self::from_raw_span(
-            x1.filename_rc(),
-            PosSpanRaw { start, end },
-        ))
+        Ok(Self::from_raw_span(PosSpanRaw { start, end }))
     }
 
     pub fn last_char(&self) -> Cow<'_, Self> {
@@ -296,10 +241,7 @@ impl Pos {
             Cow::Borrowed(self)
         } else {
             let end = self.to_raw_span().end;
-            Cow::Owned(Self::from_raw_span(
-                self.filename_rc(),
-                PosSpanRaw { start: end, end },
-            ))
+            Cow::Owned(Self::from_raw_span(PosSpanRaw { start: end, end }))
         }
     }
 
@@ -308,27 +250,24 @@ impl Pos {
             Cow::Borrowed(self)
         } else {
             let start = self.to_raw_span().start.with_column(0);
-            Cow::Owned(Self::from_raw_span(
-                self.filename_rc(),
-                PosSpanRaw { start, end: start },
-            ))
+            Cow::Owned(Self::from_raw_span(PosSpanRaw { start, end: start }))
         }
     }
 
     pub fn end_offset(&self) -> usize {
         match &self.0 {
-            PosImpl::Small { end, .. } => end.offset(),
-            PosImpl::Large { end, .. } => end.offset(),
-            PosImpl::Tiny { span, .. } => span.end_offset(),
+            PosImpl::Small { end, .. } => end.offset() as usize,
+            PosImpl::Large { end, .. } => end.offset() as usize,
+            PosImpl::Tiny { span, .. } => span.end_offset() as usize,
             PosImpl::FromReason(_p) => unimplemented!(),
         }
     }
 
     pub fn start_offset(&self) -> usize {
         match &self.0 {
-            PosImpl::Small { start, .. } => start.offset(),
-            PosImpl::Large { start, .. } => start.offset(),
-            PosImpl::Tiny { span, .. } => span.start_offset(),
+            PosImpl::Small { start, .. } => start.offset() as usize,
+            PosImpl::Large { start, .. } => start.offset() as usize,
+            PosImpl::Tiny { span, .. } => span.start_offset() as usize,
             PosImpl::FromReason(_p) => unimplemented!(),
         }
     }
@@ -338,11 +277,9 @@ impl std::fmt::Display for Pos {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         fn do_fmt<P: FilePos>(
             f: &mut std::fmt::Formatter<'_>,
-            file: &RelativePath,
             start: &P,
             end: &P,
         ) -> std::fmt::Result {
-            write!(f, "{}", file)?;
             let (start_line, start_col, _) = start.line_column_beg();
             let (end_line, end_col, _) = end.line_column_beg();
             if start_line == end_line {
@@ -352,18 +289,11 @@ impl std::fmt::Display for Pos {
             }
         }
         match &self.0 {
-            PosImpl::Small {
-                file, start, end, ..
-            } => do_fmt(f, file, start, end),
-            PosImpl::Large {
-                file, start, end, ..
-            } => do_fmt(f, file, &**start, &**end),
-            PosImpl::Tiny { span, .. } => {
-                if self.is_none() {
-                    return write!(f, "Pos::NONE");
-                }
+            PosImpl::Small { start, end, .. } => do_fmt(f, start, end),
+            PosImpl::Large { start, end, .. } => do_fmt(f, &**start, &**end),
+            PosImpl::Tiny { span } => {
                 let PosSpanRaw { start, end } = span.to_raw_span();
-                do_fmt(f, self.filename(), &start, &end)
+                do_fmt(f, &start, &end)
             }
             PosImpl::FromReason(_p) => unimplemented!(),
         }
@@ -385,9 +315,8 @@ impl Default for Pos {
 impl Ord for Pos {
     // Intended to match the implementation of `Pos.compare` in OCaml.
     fn cmp(&self, other: &Pos) -> Ordering {
-        self.filename()
-            .cmp(other.filename())
-            .then(self.start_offset().cmp(&other.start_offset()))
+        self.start_offset()
+            .cmp(&other.start_offset())
             .then(self.end_offset().cmp(&other.end_offset()))
     }
 }
@@ -425,25 +354,21 @@ impl EqModuloPos for Pos {
 impl ToOcamlRep for PosImpl {
     fn to_ocamlrep<'a, A: ocamlrep::Allocator>(&'a self, alloc: &'a A) -> ocamlrep::Value<'a> {
         match self {
-            PosImpl::Small { file, start, end } => {
-                let mut block = alloc.block_with_size_and_tag(3, 0);
-                alloc.set_field(&mut block, 0, alloc.add(file));
-                alloc.set_field(&mut block, 1, alloc.add(start));
-                alloc.set_field(&mut block, 2, alloc.add(end));
+            PosImpl::Small { start, end } => {
+                let mut block = alloc.block_with_size_and_tag(2, 0);
+                alloc.set_field(&mut block, 0, alloc.add(start));
+                alloc.set_field(&mut block, 1, alloc.add(end));
                 block.build()
             }
-            PosImpl::Large { file, start, end } => {
-                let mut block = alloc.block_with_size_and_tag(3, 1);
-                alloc.set_field(&mut block, 0, alloc.add(file));
-                alloc.set_field(&mut block, 1, alloc.add(start));
-                alloc.set_field(&mut block, 2, alloc.add(end));
+            PosImpl::Large { start, end } => {
+                let mut block = alloc.block_with_size_and_tag(2, 1);
+                alloc.set_field(&mut block, 0, alloc.add(start));
+                alloc.set_field(&mut block, 1, alloc.add(end));
                 block.build()
             }
-            PosImpl::Tiny { file, span } => {
-                let file = file.as_deref().unwrap_or(&RelativePath::EMPTY);
-                let mut block = alloc.block_with_size_and_tag(2, 2);
-                alloc.set_field(&mut block, 0, alloc.add(file));
-                alloc.set_field(&mut block, 1, alloc.add(span));
+            PosImpl::Tiny { span } => {
+                let mut block = alloc.block_with_size_and_tag(1, 2);
+                alloc.set_field(&mut block, 0, alloc.add(span));
                 block.build()
             }
             PosImpl::FromReason(pos) => {
@@ -463,7 +388,6 @@ impl FromOcamlRep for PosImpl {
             0 => {
                 from::expect_block_size(block, 3)?;
                 Ok(PosImpl::Small {
-                    file: from::field(block, 0)?,
                     start: from::field(block, 1)?,
                     end: from::field(block, 2)?,
                 })
@@ -471,20 +395,13 @@ impl FromOcamlRep for PosImpl {
             1 => {
                 from::expect_block_size(block, 3)?;
                 Ok(PosImpl::Large {
-                    file: from::field(block, 0)?,
                     start: from::field(block, 1)?,
                     end: from::field(block, 2)?,
                 })
             }
             2 => {
                 from::expect_block_size(block, 2)?;
-                let file: RelativePath = from::field(block, 0)?;
                 Ok(PosImpl::Tiny {
-                    file: if file.is_empty() {
-                        None
-                    } else {
-                        Some(RcOc::new(file))
-                    },
                     span: from::field(block, 1)?,
                 })
             }
@@ -518,20 +435,10 @@ pub struct PosString<'a>(&'a Pos, Option<&'a RelativePathCtx>);
 
 impl std::fmt::Display for PosString<'_> {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        let Self(pos, ctx) = self;
-        let path = match ctx {
-            Some(ctx) => pos.filename().to_absolute(ctx),
-            None => pos.filename().path().to_owned(),
-        };
+        let Self(pos, _) = self;
+
         let (line, start, end) = pos.info_pos();
-        write!(
-            f,
-            "File {:?}, line {}, characters {}-{}:",
-            path.display(),
-            line,
-            start,
-            end
-        )
+        write!(f, "line {}, characters {}-{}:", line, start, end)
     }
 }
 
@@ -546,7 +453,7 @@ pub mod map {
 
 impl From<parser_core_types::indexed_source_text::Pos> for Pos {
     fn from(pos: parser_core_types::indexed_source_text::Pos) -> Self {
-        Self::from_lnum_bol_offset(pos.path, pos.start, pos.end)
+        Self::from_lnum_bol_offset(pos.start, pos.end)
     }
 }
 
@@ -560,66 +467,7 @@ mod tests {
     use super::*;
 
     fn make_pos(name: &str, start: (usize, usize, usize), end: (usize, usize, usize)) -> Pos {
-        Pos::from_lnum_bol_offset(
-            RcOc::new(RelativePath::make(Prefix::Dummy, PathBuf::from(name))),
-            start,
-            end,
-        )
-    }
-
-    #[test]
-    fn test_pos() {
-        assert!(Pos::NONE.is_none());
-        assert!(
-            !Pos::from_lnum_bol_offset(
-                RcOc::new(RelativePath::make(Prefix::Dummy, PathBuf::from("a"))),
-                (0, 0, 0),
-                (0, 0, 0)
-            )
-            .is_none(),
-        );
-        assert!(
-            !Pos::from_lnum_bol_offset(
-                RcOc::new(RelativePath::make(Prefix::Dummy, PathBuf::from(""))),
-                (1, 0, 0),
-                (0, 0, 0)
-            )
-            .is_none(),
-        );
-    }
-
-    #[test]
-    fn test_pos_absolute() {
-        let ctx = RelativePathCtx {
-            dummy: PathBuf::from("dummy"),
-            ..Default::default()
-        };
-        assert_eq!(
-            Pos::NONE.absolute(&ctx).to_string(),
-            r#"File "dummy/", line 0, characters 0-0:"#
-        );
-        let path = RcOc::new(RelativePath::make(Prefix::Dummy, PathBuf::from("a.php")));
-        assert_eq!(
-            Pos::from_lnum_bol_offset(path, (5, 100, 117), (5, 100, 142))
-                .absolute(&ctx)
-                .to_string(),
-            r#"File "dummy/a.php", line 5, characters 18-42:"#
-        );
-    }
-
-    #[test]
-    fn test_pos_string() {
-        assert_eq!(
-            Pos::NONE.string().to_string(),
-            r#"File "", line 0, characters 0-0:"#
-        );
-        let path = RcOc::new(RelativePath::make(Prefix::Dummy, PathBuf::from("a.php")));
-        assert_eq!(
-            Pos::from_lnum_bol_offset(path, (5, 100, 117), (5, 100, 142))
-                .string()
-                .to_string(),
-            r#"File "a.php", line 5, characters 18-42:"#
-        );
+        Pos::from_lnum_bol_offset(start, end)
     }
 
     #[test]
diff --git a/hphp/hack/src/utils/rust/pos/pos_span_tiny.rs b/hphp/hack/src/utils/rust/pos/pos_span_tiny.rs
index dc31a9504bf..6a492ad3c3e 100644
--- a/hphp/hack/src/utils/rust/pos/pos_span_tiny.rs
+++ b/hphp/hack/src/utils/rust/pos/pos_span_tiny.rs
@@ -130,83 +130,83 @@ impl PosSpanTiny {
         ))
     }
 
-    pub fn start_beginning_of_line(self) -> usize {
+    pub fn start_beginning_of_line(self) -> u64 {
         if self.is_dummy() {
             0
         } else {
             mask_by(
                 START_BEGINNING_OF_LINE_BITS,
                 self.0 >> START_BEGINNING_OF_LINE_OFFSET,
-            ) as usize
+            )
         }
     }
 
-    pub fn start_line_number(self) -> usize {
+    pub fn start_line_number(self) -> u64 {
         if self.is_dummy() {
             0
         } else {
-            mask_by(START_LINE_NUMBER_BITS, self.0 >> START_LINE_NUMBER_OFFSET) as usize
+            mask_by(START_LINE_NUMBER_BITS, self.0 >> START_LINE_NUMBER_OFFSET)
         }
     }
 
-    pub fn start_column(self) -> usize {
+    pub fn start_column(self) -> u64 {
         if self.is_dummy() {
-            usize::MAX
+            u64::MAX
         } else {
             mask_by(
                 START_COLUMN_NUMBER_BITS,
                 self.0 >> START_COLUMN_NUMBER_OFFSET,
-            ) as usize
+            )
         }
     }
 
-    fn beginning_of_line_increment(self) -> usize {
+    fn beginning_of_line_increment(self) -> u64 {
         if self.is_dummy() {
             0
         } else {
             mask_by(
                 BEGINNING_OF_LINE_INCREMENT_BITS,
                 self.0 >> BEGINNING_OF_LINE_INCREMENT_OFFSET,
-            ) as usize
+            )
         }
     }
 
-    fn line_number_increment(self) -> usize {
+    fn line_number_increment(self) -> u64 {
         if self.is_dummy() {
             0
         } else {
             mask_by(
                 LINE_NUMBER_INCREMENT_BITS,
                 self.0 >> LINE_NUMBER_INCREMENT_OFFSET,
-            ) as usize
+            )
         }
     }
 
-    fn width(self) -> usize {
+    fn width(self) -> u64 {
         if self.is_dummy() {
             0
         } else {
-            mask_by(WIDTH_BITS, self.0 >> WIDTH_OFFSET) as usize
+            mask_by(WIDTH_BITS, self.0 >> WIDTH_OFFSET)
         }
     }
 
-    pub fn start_offset(self) -> usize {
+    pub fn start_offset(self) -> u64 {
         self.start_beginning_of_line() + self.start_column()
     }
 
-    pub fn end_line_number(self) -> usize {
+    pub fn end_line_number(self) -> u64 {
         self.start_line_number() + self.line_number_increment()
     }
 
-    pub fn end_beginning_of_line(self) -> usize {
+    pub fn end_beginning_of_line(self) -> u64 {
         self.start_beginning_of_line() + self.beginning_of_line_increment()
     }
 
-    pub fn end_offset(self) -> usize {
+    pub fn end_offset(self) -> u64 {
         self.start_offset() + self.width()
     }
 
-    pub fn end_column(self) -> usize {
+    pub fn end_column(self) -> u64 {
         self.end_offset() - self.end_beginning_of_line()
     }
 
@@ -221,8 +221,16 @@ impl PosSpanTiny {
             let end_bol = self.end_beginning_of_line();
             let end_offset = self.end_offset();
             PosSpanRaw {
-                start: FilePosLarge::from_lnum_bol_offset(start_lnum, start_bol, start_offset),
-                end: FilePosLarge::from_lnum_bol_offset(end_lnum, end_bol, end_offset),
+                start: FilePosLarge::from_lnum_bol_offset(
+                    start_lnum as u64,
+                    start_bol as u64,
+                    start_offset as u64,
+                ),
+                end: FilePosLarge::from_lnum_bol_offset(
+                    end_lnum as u64,
+                    end_bol as u64,
+                    end_offset as u64,
+                ),
             }
         }
     }
