diff --cc hphp/hack/src/decl/cargo/rust_decl_ffi/Cargo.toml
index 48eff2109c7,7deac576a18..00000000000
--- a/hphp/hack/src/decl/cargo/rust_decl_ffi/Cargo.toml
+++ b/hphp/hack/src/decl/cargo/rust_decl_ffi/Cargo.toml
@@@ -20,11 -17,11 +20,13 @@@ crossbeam = "0.8
  direct_decl_parser = { version = "0.0.0", path = "../../../parser/api/cargo/direct_decl_parser" }
  hh_hash = { version = "0.0.0", path = "../../../utils/hh_hash" }
  ocamlrep = { version = "0.1.0", git = "https://github.com/facebook/ocamlrep/", branch = "main" }
- ocamlrep_caml_builtins = { version = "0.1.0", git = "https://github.com/facebook/ocamlrep/", branch = "main" }
 +ocamlrep_custom = { version = "0.1.0", git = "https://github.com/facebook/ocamlrep/", branch = "main" }
  ocamlrep_ocamlpool = { version = "0.1.0", git = "https://github.com/facebook/ocamlrep/", branch = "main" }
  oxidized = { version = "0.0.0", path = "../../../oxidized" }
  oxidized_by_ref = { version = "0.0.0", path = "../../../oxidized_by_ref" }
  parser_core_types = { version = "0.0.0", path = "../../../parser/cargo/core_types" }
 +rayon = "1.2"
  relative_path = { version = "0.0.0", path = "../../../utils/rust/relative_path" }
+ 
+ [target.'cfg(not(target_arch = "wasm32"))'.dependencies]
+ ocamlrep_caml_builtins = { version = "0.1.0", git = "https://github.com/facebook/ocamlrep/", branch = "main" }
diff --cc hphp/hack/src/deps/rust/file_info.rs
index e3a025dc023,122c094ba64..00000000000
--- a/hphp/hack/src/deps/rust/file_info.rs
+++ b/hphp/hack/src/deps/rust/file_info.rs
@@@ -213,11 -121,7 +213,11 @@@ pub enum Pos 
  )]
  #[rust_to_ocaml(attr = "deriving (eq, show)")]
  #[repr(C)]
 -pub struct Id(pub Pos, pub String, pub Option<u64>);
 +pub struct Id {
 +    pub pos: Pos,
 +    pub name: String,
-     pub decl_hash: Option<Int64>,
++    pub decl_hash: Option<u64>,
 +}
  
  #[derive(
      Clone,
@@@ -236,8 -140,9 +236,8 @@@
  )]
  #[rust_to_ocaml(attr = "deriving eq")]
  #[repr(C)]
- pub struct HashType(pub Option<Int64>);
+ pub struct HashType(pub Option<u64>);
  
 -/// The record produced by the parsing phase.
  #[derive(
      Clone,
      Debug,
@@@ -287,30 -171,6 +287,30 @@@ pub struct FileInfo 
      pub comments: Option<Vec<(pos::Pos, Comment)>>,
  }
  
- pub type PfhHash = Int64;
++pub type PfhHash = u64;
 +
 +#[derive(
 +    Clone,
 +    Debug,
 +    Deserialize,
 +    Eq,
 +    FromOcamlRep,
 +    Hash,
 +    NoPosHash,
 +    Ord,
 +    PartialEq,
 +    PartialOrd,
 +    Serialize,
 +    ToOcamlRep,
 +)]
 +#[repr(C)]
 +pub struct Change {
 +    pub path: relative_path::RelativePath,
 +    pub old_ids: Option<Ids>,
 +    pub new_ids: Option<Ids>,
 +    pub new_pfh_hash: Option<PfhHash>,
 +}
 +
  /// The simplified record used after parsing.
  #[derive(
      Clone,
diff --cc hphp/hack/src/oxidized_by_ref/gen/file_info.rs
index 89410c84e9d,b3cd4c553ef..00000000000
--- a/hphp/hack/src/oxidized_by_ref/gen/file_info.rs
+++ b/hphp/hack/src/oxidized_by_ref/gen/file_info.rs
@@@ -11,10 -11,8 +11,9 @@@
  use arena_trait::TrivialDrop;
  use eq_modulo_pos::EqModuloPos;
  use no_pos_hash::NoPosHash;
 +use ocamlrep::FromOcamlRep;
  use ocamlrep::FromOcamlRepIn;
  use ocamlrep::ToOcamlRep;
- use ocamlrep_caml_builtins::Int64;
  pub use oxidized::file_info::Mode;
  pub use oxidized::file_info::NameType;
  pub use prim_defs::*;
@@@ -173,14 -76,11 +172,14 @@@ arena_deserializer::impl_deserialize_in
  )]
  #[rust_to_ocaml(attr = "deriving (eq, show)")]
  #[repr(C)]
 -pub struct Id<'a>(
 -    #[serde(deserialize_with = "arena_deserializer::arena", borrow)] pub Pos<'a>,
 -    #[serde(deserialize_with = "arena_deserializer::arena", borrow)] pub &'a str,
 -    #[serde(deserialize_with = "arena_deserializer::arena", borrow)] pub Option<&'a u64>,
 -);
 +pub struct Id<'a> {
 +    #[serde(deserialize_with = "arena_deserializer::arena", borrow)]
 +    pub pos: Pos<'a>,
 +    #[serde(deserialize_with = "arena_deserializer::arena", borrow)]
 +    pub name: &'a str,
 +    #[serde(deserialize_with = "arena_deserializer::arena", borrow)]
-     pub decl_hash: Option<&'a Int64>,
++    pub decl_hash: Option<&'a u64>,
 +}
  impl<'a> TrivialDrop for Id<'a> {}
  arena_deserializer::impl_deserialize_in_arena!(Id<'arena>);
  
@@@ -268,36 -145,6 +267,36 @@@ pub struct FileInfo<'a> 
  impl<'a> TrivialDrop for FileInfo<'a> {}
  arena_deserializer::impl_deserialize_in_arena!(FileInfo<'arena>);
  
- pub type PfhHash<'a> = Int64;
++pub type PfhHash<'a> = u64;
 +
 +#[derive(
 +    Clone,
 +    Debug,
 +    Deserialize,
 +    Eq,
 +    FromOcamlRepIn,
 +    Hash,
 +    NoPosHash,
 +    Ord,
 +    PartialEq,
 +    PartialOrd,
 +    Serialize,
 +    ToOcamlRep
 +)]
 +#[repr(C)]
 +pub struct Change<'a> {
 +    #[serde(deserialize_with = "arena_deserializer::arena", borrow)]
 +    pub path: &'a relative_path::RelativePath<'a>,
 +    #[serde(deserialize_with = "arena_deserializer::arena", borrow)]
 +    pub old_ids: Option<&'a Ids<'a>>,
 +    #[serde(deserialize_with = "arena_deserializer::arena", borrow)]
 +    pub new_ids: Option<&'a Ids<'a>>,
 +    #[serde(deserialize_with = "arena_deserializer::arena", borrow)]
 +    pub new_pfh_hash: Option<&'a PfhHash<'a>>,
 +}
 +impl<'a> TrivialDrop for Change<'a> {}
 +arena_deserializer::impl_deserialize_in_arena!(Change<'arena>);
 +
  pub use oxidized::file_info::Names;
  
  /// The simplified record stored in saved-state.
diff --cc hphp/hack/src/parser/aast_parser.rs
index 01413aba90c,93d79e22298..00000000000
--- a/hphp/hack/src/parser/aast_parser.rs
+++ b/hphp/hack/src/parser/aast_parser.rs
@@@ -85,14 -85,7 +85,14 @@@ impl<'src> AastParser 
          indexed_source_text: &'src IndexedSourceText<'src>,
          default_unstable_features: HashSet<rust_parser_errors::UnstableFeatures>,
      ) -> Result<ParserResult> {
 +        // TODO(T120858428): remove this check (and always verify_utf8) once
 +        // we're strict everywhere!
 +        if env.parser_options.po_strict_utf8 {
 +            if let Some(err) = Self::verify_utf8(indexed_source_text) {
 +                return Ok(err);
 +            }
 +        }
-         let start_t = Instant::now();
+         //let start_t = Instant::now();
          let arena = Bump::new();
          stack_limit::reset();
          let (language, mode, tree) = Self::parse_text(&arena, env, indexed_source_text)?;
@@@ -358,9 -333,15 +358,9 @@@
                      disable_hh_ignore_error: env.parser_options.po_disable_hh_ignore_error,
                      allowed_decl_fixme_codes: &env.parser_options.po_allowed_decl_fixme_codes,
                  };
-             Ok(scourer.scour_comments(script))
+             Ok(scourer.scour_comments(script, indexed_source_text.source_text().file_path()))
          } else {
 -            Ok(ScouredComments {
 -                comments: Default::default(),
 -                fixmes: Default::default(),
 -                misuses: Default::default(),
 -                error_pos: Default::default(),
 -                bad_ignore_pos: Default::default(),
 -            })
 +            Ok(default_scoured_comments())
          }
      }
  }
diff --cc hphp/hack/src/providers/hackrs_provider_backend/Cargo.toml
index 711c6045eda,154f2cdb3d5..00000000000
--- a/hphp/hack/src/providers/hackrs_provider_backend/Cargo.toml
+++ b/hphp/hack/src/providers/hackrs_provider_backend/Cargo.toml
diff --cc hphp/hack/src/utils/arena_deserializer/Cargo.toml
index d0f6c7271be,6a697f0fb42..00000000000
--- a/hphp/hack/src/utils/arena_deserializer/Cargo.toml
+++ b/hphp/hack/src/utils/arena_deserializer/Cargo.toml
@@@ -12,6 -10,8 +12,8 @@@ path = "lib.rs
  
  [dependencies]
  bstr = { version = "1.4.0", features = ["serde", "std", "unicode"] }
 -bumpalo = { version = "3.11.1", features = ["collections"] }
 +bumpalo = { version = "3.14.0", features = ["allocator_api", "collections"] }
- ocamlrep_caml_builtins = { version = "0.1.0", git = "https://github.com/facebook/ocamlrep/", branch = "main" }
  serde = { version = "1.0.185", features = ["derive", "rc"] }
+ 
+ [target.'cfg(not(target_arch = "wasm32"))'.dependencies]
+ ocamlrep_caml_builtins = { version = "0.1.0", git = "https://github.com/facebook/ocamlrep/", branch = "main" }
diff --cc hphp/hack/src/utils/eq_modulo_pos/Cargo.toml
index 191268eb7de,22ec5903b71..00000000000
--- a/hphp/hack/src/utils/eq_modulo_pos/Cargo.toml
+++ b/hphp/hack/src/utils/eq_modulo_pos/Cargo.toml
@@@ -15,5 -13,7 +15,7 @@@ arena_collections = { version = "0.0.0"
  bstr = { version = "1.4.0", features = ["serde", "std", "unicode"] }
  eq_modulo_pos_derive = { version = "0.0.0", path = "../eq_modulo_pos_derive" }
  hcons = { version = "0.0.0", path = "../../hcons" }
 -indexmap = { version = "1.9.2", features = ["arbitrary", "rayon", "serde-1"] }
 +indexmap = { version = "2.1.0", features = ["arbitrary", "rayon", "serde"] }
+ 
+ [target.'cfg(not(target_arch = "wasm32"))'.dependencies]
  ocamlrep_caml_builtins = { version = "0.1.0", git = "https://github.com/facebook/ocamlrep/", branch = "main" }
diff --git a/hphp/hack/src/utils/rust/pos/pos_span_tiny.rs b/hphp/hack/src/utils/rust/pos/pos_span_tiny.rs
index 6a492ad3c3e..a6149eab11f 100644
--- a/hphp/hack/src/utils/rust/pos/pos_span_tiny.rs
+++ b/hphp/hack/src/utils/rust/pos/pos_span_tiny.rs
@@ -376,9 +376,9 @@ mod test {
         let start_offset = u64::max_value();
         let end_offset = u64::max_value();
         let start =
-            FilePosLarge::from_lnum_bol_offset(line as usize, bol as usize, start_offset as usize);
+            FilePosLarge::from_lnum_bol_offset(line, bol, start_offset);
         let end =
-            FilePosLarge::from_lnum_bol_offset(line as usize, bol as usize, end_offset as usize);
+            FilePosLarge::from_lnum_bol_offset(line, bol, end_offset);
         let span = PosSpanTiny::make_dummy();
         assert_eq!(line, span.start_line_number() as u64);
         assert_eq!(line, span.end_line_number() as u64);
@@ -404,9 +404,9 @@ mod test {
         let start_offset = max_int;
         let end_offset = max_int;
         let start =
-            FilePosLarge::from_lnum_bol_offset(line as usize, bol as usize, start_offset as usize);
+            FilePosLarge::from_lnum_bol_offset(line, bol, start_offset);
         let end =
-            FilePosLarge::from_lnum_bol_offset(line as usize, bol as usize, end_offset as usize);
+            FilePosLarge::from_lnum_bol_offset(line, bol, end_offset);
         match PosSpanTiny::make(&start, &end) {
             None => {
                 // expected
@@ -440,8 +440,8 @@ mod test {
         let bol = 1667611usize;
         let start_offset = 1667617usize;
         let end_offset = 1667673usize;
-        let start = FilePosLarge::from_lnum_bol_offset(line, bol, start_offset);
-        let end = FilePosLarge::from_lnum_bol_offset(line, bol, end_offset);
+        let start = FilePosLarge::from_lnum_bol_offset(line as u64, bol as u64, start_offset as u64);
+        let end = FilePosLarge::from_lnum_bol_offset(line as u64, bol as u64, end_offset as u64);
         let span = PosSpanTiny::make(&start, &end).unwrap();
 
         // Though the span fits nicely into 63-bits, the resulting value is > 2^62 -
